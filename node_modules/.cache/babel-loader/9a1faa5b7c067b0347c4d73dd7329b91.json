{"ast":null,"code":"/*\nCopyright (c) NAVER Crop.\nname: @cfcs/core\nlicense: MIT\nauthor: NAVER Crop.\nrepository: https://github.com/naver/cfcs\nversion: 0.0.4\n*/\nimport Component from '@egjs/component';\n/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\n\nfunction keys(obj) {\n  return Object.keys(obj);\n}\n\nfunction camelize(str) {\n  return str.replace(/[\\s-_]([a-z])/g, function (all, letter) {\n    return letter.toUpperCase();\n  });\n}\n\nfunction isObject(val) {\n  return typeof val === \"object\";\n}\n\nfunction isFunction(val) {\n  return typeof val === \"function\";\n}\n\nfunction withClassMethods(methods) {\n  return function (prototype, memberName) {\n    methods.forEach(function (name) {\n      if (name in prototype) {\n        return;\n      }\n\n      prototype[name] = function () {\n        var _a;\n\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var result = (_a = this[memberName])[name].apply(_a, args); // fix `this` type to return your own `class` instance to the instance using the decorator.\n\n\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n\nvar OBSERVERS_PATH = \"__observers__\";\n\nvar Observer = /*#__PURE__*/function () {\n  function Observer(value) {\n    this._emitter = new Component();\n    this._current = value;\n  }\n\n  var __proto = Observer.prototype;\n  Object.defineProperty(__proto, \"current\", {\n    get: function () {\n      return this._current;\n    },\n    set: function (value) {\n      var isUpdate = value !== this._current;\n      this._current = value;\n\n      if (isUpdate) {\n        this._emitter.trigger(\"update\", value);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __proto.subscribe = function (callback) {\n    this._emitter.on(\"update\", callback);\n  };\n\n  __proto.unsubscribe = function (callback) {\n    this._emitter.off(\"update\", callback);\n  };\n\n  return Observer;\n}();\n\nfunction withReactiveMethods(ref, methods) {\n  var obj = {};\n\n  if (!methods) {\n    return obj;\n  }\n\n  methods.forEach(function (name) {\n    obj[name] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var current = ref.current || ref.value;\n      return current[name].apply(current, args);\n    };\n  });\n  return obj;\n}\n\nfunction observe(defaultValue) {\n  return new Observer(defaultValue);\n}\n\nfunction getObservers(instance) {\n  if (!instance[OBSERVERS_PATH]) {\n    instance[OBSERVERS_PATH] = {};\n  }\n\n  return instance[OBSERVERS_PATH];\n}\n\nfunction getObserver(instance, name, defaultValue) {\n  var observers = getObservers(instance);\n\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n\n  return observers[name];\n}\n\nfunction setObserver(instance, name, observer) {\n  var observers = getObservers(instance);\n  observers[name] = observer;\n}\n\nfunction isObserver(val) {\n  return val && \"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n\nfunction Reactive(name) {\n  return function (prototype, memberName) {\n    var publicName = name || memberName;\n    Object.defineProperty(prototype, memberName, {\n      get: function () {\n        return getObserver(this, publicName).current;\n      },\n      set: function (value) {\n        getObserver(this, publicName, value).current = value;\n      }\n    });\n\n    if (publicName !== memberName) {\n      Object.defineProperty(prototype, publicName, {\n        get: function () {\n          return getObserver(this, publicName).current;\n        }\n      });\n    }\n  };\n}\n\nfunction injectReactiveSubscribe(object) {\n  object[\"subscribe\"] = function (name, callback) {\n    getObserver(this, name).subscribe(callback);\n  };\n\n  object[\"unsubscribe\"] = function (name, callback) {\n    var _this = this;\n\n    if (!name) {\n      keys(getObservers(this)).forEach(function (observerName) {\n        _this.unsubscribe(observerName);\n      });\n      return;\n    }\n\n    if (!(name in this)) {\n      return;\n    }\n\n    getObserver(this, name).unsubscribe(callback);\n  };\n}\n\nfunction ReactiveSubscribe(Constructor) {\n  var prototype = Constructor.prototype;\n  injectReactiveSubscribe(prototype);\n}\n\nfunction reactive(setup) {\n  var result = isFunction(setup) ? setup() : setup;\n  var reactiveObject = {};\n  keys(result).forEach(function (name) {\n    var value = result[name];\n\n    if (isObserver(value)) {\n      setObserver(reactiveObject, name, value);\n      Reactive(name)(reactiveObject, name);\n    } else {\n      reactiveObject[name] = value;\n    }\n  });\n  injectReactiveSubscribe(reactiveObject);\n  return reactiveObject;\n}\n\nfunction adaptReactive(adapter) {\n  var _a;\n\n  function data() {\n    var _a, _b;\n\n    return (_b = (_a = adapter.data) === null || _a === void 0 ? void 0 : _a.call(adapter)) !== null && _b !== void 0 ? _b : {};\n  }\n\n  var instanceRef = {\n    current: ((_a = adapter.created) === null || _a === void 0 ? void 0 : _a.call(adapter, data())) || null\n  };\n  var firstState = null;\n  return {\n    state: function () {\n      var inst = instanceRef.current;\n\n      if (firstState) {\n        return firstState;\n      }\n\n      if (adapter.state) {\n        firstState = adapter.state;\n      } else if (inst) {\n        var observers_1 = getObservers(inst);\n        firstState = keys(observers_1).reduce(function (prev, cur) {\n          prev[cur] = observers_1[cur].current;\n          return prev;\n        }, {});\n      }\n\n      return firstState || {};\n    },\n    instance: function () {\n      return instanceRef.current;\n    },\n    mounted: function () {\n      var _a;\n\n      instanceRef.current = ((_a = adapter.mounted) === null || _a === void 0 ? void 0 : _a.call(adapter, data())) || instanceRef.current;\n    },\n    init: function () {\n      var _a;\n\n      (_a = adapter.init) === null || _a === void 0 ? void 0 : _a.call(adapter, instanceRef.current, data());\n    },\n    destroy: function () {\n      var _a;\n\n      (_a = adapter.destroy) === null || _a === void 0 ? void 0 : _a.call(adapter, instanceRef.current, data());\n    },\n    methods: function () {\n      return withReactiveMethods(instanceRef, adapter.methods);\n    },\n    on: function (eventName, listener) {\n      var _a;\n\n      (_a = adapter.on) === null || _a === void 0 ? void 0 : _a.call(adapter, instanceRef.current, eventName, listener);\n    },\n    off: function (eventName, listener) {\n      var _a;\n\n      (_a = adapter.off) === null || _a === void 0 ? void 0 : _a.call(adapter, instanceRef.current, eventName, listener);\n    }\n  };\n}\n\nexport { Observer, Reactive, ReactiveSubscribe, adaptReactive, camelize, getObserver, getObservers, injectReactiveSubscribe, isFunction, isObject, isObserver, keys, observe, reactive, setObserver, withClassMethods, withReactiveMethods };","map":{"version":3,"mappings":"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","names":["keys","obj","Object","camelize","str","replace","all","letter","toUpperCase","isObject","val","isFunction","withClassMethods","methods","prototype","memberName","forEach","name","args","_i","arguments","result","apply","_a","OBSERVERS_PATH","value","Component","_current","__proto","get","set","isUpdate","_emitter","trigger","subscribe","callback","on","unsubscribe","off","Observer","ref","current","observe","defaultValue","getObservers","instance","getObserver","observers","setObserver","observer","isObserver","Reactive","publicName","defineProperty","injectReactiveSubscribe","object","_this","observerName","ReactiveSubscribe","Constructor","reactive","setup","reactiveObject","adaptReactive","adapter","data","_b","instanceRef","created","firstState","state","inst","observers_1","reduce","prev","cur","mounted","init","destroy","withReactiveMethods","eventName","listener"],"sources":["../src/core/utils.ts","../src/dom/utils.ts","../src/reactive/const.ts","../src/reactive/Observer.ts","../src/reactive/utils.ts","../src/reactive/Reactive.ts","../src/reactive/ReactiveSubscribe.ts","../src/reactive/inlineReactive.ts","../src/reactive/adaptReactive.ts"],"sourcesContent":["/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nexport function keys<T extends Record<string, any>>(obj: T): Array<keyof T> {\n  return Object.keys(obj);\n}\n\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n\nexport function isObject(val: any): val is object {\n  return typeof val === \"object\";\n}\nexport function isFunction(val: any): val is Function {\n  return typeof val === \"function\";\n}","\nexport function withClassMethods(methods: readonly string[]) {\n  return function (prototype: any, memberName: string) {\n    methods.forEach((name: string) => {\n      if (name in prototype) {\n        return;\n      }\n      prototype[name] = function (...args) {\n        const result = this[memberName][name](...args);\n\n        // fix `this` type to return your own `class` instance to the instance using the decorator.\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n","export const OBSERVERS_PATH = \"__observers__\";\nexport const REACTIVE_PATH = \"__reactive__\";\n","import Component from \"@egjs/component\";\n\ninterface EmitterEvents<Value> {\n  update: (value: Value) => void;\n}\n\nexport class Observer<Value = any> {\n  private _current: Value;\n  private _emitter = new Component<EmitterEvents<Value>>();\n\n  constructor(value?: Value) {\n    this._current = value as any;\n  }\n  public get current() {\n    return this._current as Value;\n  }\n  public set current(value: Value) {\n    const isUpdate = value !== this._current;\n    this._current = value;\n\n    if (isUpdate) {\n      this._emitter.trigger(\"update\", value);\n    }\n  }\n  public subscribe(callback: (value: Value) => void) {\n    this._emitter.on(\"update\", callback);\n  }\n  public unsubscribe(callback?: (value: Value) => void) {\n    this._emitter.off(\"update\", callback);\n  }\n}\n","import { OBSERVERS_PATH } from \"./const\";\nimport { Observer } from \"./Observer\";\nimport { ReactiveMethods } from \"./types\";\nimport { Ref } from \"../core\";\n\n\nexport function withReactiveMethods<\n  Instance,\n  Names extends keyof Partial<Instance>,\n  Return extends ReactiveMethods<Instance, Names>\n>(ref: Ref<Instance>, methods?: readonly Names[]): Return {\n  const obj: Record<any, any> = {};\n\n  if (!methods) {\n    return obj;\n  }\n\n  methods.forEach(name => {\n    obj[name] = function (...args: any[]) {\n      const current: any = ref.current || ref.value;\n\n      return current[name](...args);\n    };\n  });\n  return obj as Return;\n}\n\n\nexport function observe<Type>(defaultValue?: Type): Observer<Type> {\n  return new Observer<Type>(defaultValue);\n}\n\nexport function getObservers(instance: any): Record<string, Observer<any>> {\n  if (!instance[OBSERVERS_PATH]) {\n    instance[OBSERVERS_PATH] = {};\n  }\n  return instance[OBSERVERS_PATH];\n}\n\nexport function getObserver(instance: any, name: string, defaultValue?: any): Observer<any> {\n  const observers = getObservers(instance);\n\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n  return observers[name];\n}\n\nexport function setObserver(instance: any, name: string, observer: Observer<any>) {\n  const observers = getObservers(instance);\n\n  observers[name] = observer;\n}\n\nexport function isObserver(val: any): val is Observer {\n  return val && (\"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val);\n}","import { getObserver } from \"./utils\";\n\nexport function Reactive(name?: string) {\n    return function (prototype: any, memberName: string) {\n        const publicName = name || memberName;\n\n        Object.defineProperty(prototype, memberName, {\n            get: function () {\n                return getObserver(this, publicName).current;\n            },\n            set: function (value: any) {\n                getObserver(this, publicName, value).current = value;\n            },\n        });\n        if (publicName !== memberName) {\n            Object.defineProperty(prototype, publicName, {\n                get: function () {\n                    return getObserver(this, publicName).current;\n                },\n            });\n        }\n    };\n}\n\n","import { keys } from \"../core\";\nimport { getObserver, getObservers } from \"./utils\";\n\nexport function injectReactiveSubscribe(object: Record<string, any>, ) {\n    object[\"subscribe\"] = function (name: string, callback: (value: any) => void) {\n        getObserver(this, name).subscribe(callback);\n    };\n    object[\"unsubscribe\"] = function (name?: string, callback?: (value: any) => void) {\n        if (!name) {\n            keys(getObservers(this)).forEach((observerName) => {\n                this.unsubscribe(observerName);\n            });\n            return;\n        }\n        if (!(name in this)) {\n            return;\n        }\n        getObserver(this, name).unsubscribe(callback);\n    };\n}\n\nexport function ReactiveSubscribe(Constructor: any) {\n    const prototype = Constructor.prototype;\n\n    injectReactiveSubscribe(prototype);\n}\n\nexport interface ReactiveSubscribe<Properties extends Record<string, any>> {\n    subscribe<Name extends keyof Properties = keyof Properties>(\n        name: Name, callback: (value: Properties[Name]) => void): void;\n    unsubscribe<Name extends keyof Properties = keyof Properties>(\n        name?: Name, callback?: (value: Properties[Name]) => void): void;\n}","import { ExtractNever, isFunction, keys } from \"../core\";\nimport { Observer } from \"./Observer\";\nimport { Reactive } from \"./Reactive\";\nimport { injectReactiveSubscribe, ReactiveSubscribe } from \"./ReactiveSubscribe\";\nimport { isObserver, setObserver } from \"./utils\";\n\n\ntype ConvertValue<Object extends Record<string, any>> = {\n    [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : Object[Key];\n}\n\ntype PickObverser<Object extends Record<string, any>> = ExtractNever<{\n    [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : never;\n}>;\n\nexport type ReactiveObject<Object extends Record<string, any>>\n    = ConvertValue<Object> & ReactiveSubscribe<PickObverser<Object>>;\n\nexport function reactive<Object extends Record<string, any>>(\n    setup: Readonly<Object> | (() => Readonly<Object>),\n): ReactiveObject<Object> {\n    const result = isFunction(setup) ? setup() : setup;\n    const reactiveObject: Record<string, any> = {};\n\n    keys(result).forEach((name: any) => {\n        const value = result[name];\n        if (isObserver(value)) {\n            setObserver(reactiveObject, name, value);\n            Reactive(name)(reactiveObject, name);\n        } else {\n            reactiveObject[name] = value;\n        }\n    });\n\n    injectReactiveSubscribe(reactiveObject);\n    return reactiveObject as ReactiveObject<Object>;\n}\n","import { keys } from \"src/core\";\nimport { Ref } from \"src/core/types\";\nimport { ReactiveAdapter } from \"./ReactiveAdapter\";\nimport { ReactiveSubscribe } from \"./ReactiveSubscribe\";\nimport { ReactiveEventCallback } from \"./types\";\nimport { getObservers, withReactiveMethods } from \"./utils\";\n\nexport function adaptReactive<\n    Instance extends ReactiveSubscribe<Record<string, any>>,\n    State extends Record<string, any> = {},\n    Methods extends keyof Partial<Instance> = any,\n    Data = any,\n    Events extends Record<string, any> = {},\n    >(adapter: ReactiveAdapter<Instance, State, Methods, Data, Events>) {\n\n    function data(): Data {\n        return adapter.data?.() ?? {} as Data;\n    }\n\n    const instanceRef: Ref<Instance> = { current: adapter.created?.(data()) || null };\n    let firstState: State | null = null;\n    \n    return {\n        state(): State {\n            const inst = instanceRef.current;\n\n            if (firstState) {\n                return firstState;\n            }\n            if (adapter.state) {\n                firstState = adapter.state;\n            } else if (inst) {\n                const observers = getObservers(inst);\n\n                firstState = keys(observers).reduce((prev, cur) => {\n                    prev[cur] = observers[cur].current;\n                    return prev;\n                }, {} as any);\n            }\n            return firstState || {} as State;\n        },\n        instance() {\n            return instanceRef.current;\n        },\n        mounted(): void {\n            instanceRef.current = adapter.mounted?.(data()) || instanceRef.current;\n        },\n        init(): void {\n            adapter.init?.(instanceRef.current!, data());\n        },\n        destroy(): void {\n            adapter.destroy?.(instanceRef.current!, data());\n        },\n        methods() {\n            return withReactiveMethods<any, any, any>(instanceRef, adapter.methods);\n        },\n        on(eventName: string, listener: ReactiveEventCallback<any, any>) {\n            adapter.on?.(instanceRef.current!, eventName as never, listener);\n        },\n        off(eventName: string, listener: ReactiveEventCallback<any, any>) {\n            adapter.off?.(instanceRef.current!, eventName as never, listener);\n        },\n    };\n}"]},"metadata":{},"sourceType":"module"}