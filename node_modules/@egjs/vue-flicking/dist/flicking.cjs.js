/*
Copyright (c) 2015-present NAVER Corp.
name: @egjs/vue-flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking/tree/master/packages/vue-flicking
version: 4.9.2
*/
'use strict';

var ListDiffer = require('@egjs/list-differ');
var Vue = require('vue');
var VanillaFlicking = require('@egjs/flicking');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

var VueRenderer =
/*#__PURE__*/
function (_super) {
  __extends(VueRenderer, _super);

  function VueRenderer(options) {
    var _this = _super.call(this, options) || this;

    _this._vueFlicking = options.vueFlicking;
    return _this;
  }

  var __proto = VueRenderer.prototype;

  __proto.render = function () {
    return __awaiter(this, void 0, void 0, function () {
      var flicking, vueFlicking, strategy;
      return __generator(this, function (_a) {
        flicking = VanillaFlicking.getFlickingAttached(this._flicking);
        vueFlicking = this._vueFlicking;
        strategy = this._strategy;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        return [2
        /*return*/
        , new Promise(function (resolve) {
          vueFlicking.$once("render", resolve);
          vueFlicking.$forceUpdate();
        })];
      });
    });
  };

  __proto.forceRenderAllPanels = function () {
    return __awaiter(this, void 0, void 0, function () {
      var vueFlicking;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            vueFlicking = this._vueFlicking;
            return [4
            /*yield*/
            , _super.prototype.forceRenderAllPanels.call(this)];

          case 1:
            _a.sent();

            return [2
            /*return*/
            , new Promise(function (resolve) {
              vueFlicking.$once("render", resolve);
              vueFlicking.$forceUpdate();
            })];
        }
      });
    });
  };

  __proto._collectPanels = function () {
    var flicking = VanillaFlicking.getFlickingAttached(this._flicking);
    var vueFlicking = this._vueFlicking;
    var vuePanels = vueFlicking.$children;
    this._panels = this._strategy.collectPanels(flicking, vuePanels);
  };

  __proto._createPanel = function (externalComponent, options) {
    return this._strategy.createPanel(externalComponent, options);
  };

  return VueRenderer;
}(VanillaFlicking.ExternalRenderer);

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var VuePanel = Vue.extend({
  data: function () {
    return {
      hide: false
    };
  },
  render: function () {
    var _a;

    var children = this.hide ? undefined : (_a = this.$slots.default) !== null && _a !== void 0 ? _a : []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion

    return children;
  },
  methods: {
    getElement: function () {
      return this.$el;
    }
  }
});

var VueElementProvider =
/*#__PURE__*/
function () {
  function VueElementProvider(el) {
    this._el = el;
  }

  var __proto = VueElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._el.getElement();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return !this._el.hide;
    },
    enumerable: false,
    configurable: true
  });

  __proto.show = function () {
    this._el.hide = false;
  };

  __proto.hide = function () {
    this._el.hide = true;
  };

  return VueElementProvider;
}();

var FlickingProps = {
  viewportTag: {
    type: String,
    default: "div",
    required: false
  },
  cameraTag: {
    type: String,
    default: "div",
    required: false
  },
  hideBeforeInit: {
    type: Boolean,
    default: false,
    required: false
  },
  firstPanelSize: {
    type: String,
    required: false
  },
  options: {
    type: Object,
    default: function () {
      return {};
    },
    required: false
  },
  plugins: {
    type: Array,
    default: function () {
      return [];
    },
    required: false
  },
  status: {
    type: Object,
    required: false
  }
};

var getSlots = function (component) {
  var _a, _b;

  return (_b = (_a = component.$slots.default) === null || _a === void 0 ? void 0 : _a.filter(function (slot) {
    return slot.tag;
  })) !== null && _b !== void 0 ? _b : [];
};
var fillKeys = function (component) {
  var vnodes = getSlots(component);
  vnodes.forEach(function (node, idx) {
    if (node.key == null) {
      node.key = "$_".concat(idx);
    }
  });
};

var Flicking = Vue.extend({
  props: FlickingProps,
  components: {
    Panel: VuePanel
  },
  data: function () {
    // Mocking the type, as we don't want them to be reactive
    return {};
  },
  created: function () {
    this.diffResult = null;
    VanillaFlicking.withFlickingMethods(this, "vanillaFlicking");
  },
  mounted: function () {
    var _this = this;

    var _a;

    var options = this.options;
    var viewportEl = this.$el;
    var rendererOptions = {
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
      vueFlicking: this,
      align: options.align,
      strategy: options.virtual && ((_a = options.panelsPerView) !== null && _a !== void 0 ? _a : -1) > 0 ? new VanillaFlicking.VirtualRenderingStrategy() : new VanillaFlicking.NormalRenderingStrategy({
        providerCtor: VueElementProvider
      })
    };
    var flicking = new VanillaFlicking(viewportEl, __assign(__assign({}, options), {
      externalRenderer: new VueRenderer(rendererOptions)
    }));
    this.vanillaFlicking = flicking;
    flicking.once(VanillaFlicking.EVENTS.READY, function () {
      _this.$forceUpdate();
    });
    var slots = getSlots(this);
    this.slotDiffer = new ListDiffer(slots, function (vnode) {
      return vnode.key;
    });
    this.pluginsDiffer = new ListDiffer();

    this._bindEvents();

    this._checkPlugins();

    if (this.status) {
      flicking.setStatus(this.status);
    }
  },
  beforeDestroy: function () {
    var _a;

    (_a = this.vanillaFlicking) === null || _a === void 0 ? void 0 : _a.destroy();
  },
  beforeMount: function () {
    fillKeys(this);
  },
  beforeUpdate: function () {
    fillKeys(this);
    this.diffResult = this.slotDiffer.update(getSlots(this));
  },
  updated: function () {
    var flicking = this.vanillaFlicking;
    var diffResult = this.diffResult;

    this._checkPlugins();

    this.$emit("render");
    if (!diffResult || !flicking.initialized) return;
    VanillaFlicking.sync(flicking, diffResult, this.$children);

    if (diffResult.added.length > 0 || diffResult.removed.length > 0) {
      this.$forceUpdate();
    }

    this.diffResult = null;
  },
  render: function (h) {
    var _a, _b;

    var flicking = this.vanillaFlicking;
    var options = this.options;
    var initialized = !!this.diffResult && flicking && flicking.initialized;
    var isHorizontal = flicking ? flicking.horizontal : (_a = options.horizontal) !== null && _a !== void 0 ? _a : true;
    var viewportData = {
      class: {
        "flicking-viewport": true,
        "vertical": !isHorizontal,
        "flicking-hidden": this.hideBeforeInit && !initialized
      }
    };
    var cameraData = {
      class: {
        "flicking-camera": true
      },
      style: !initialized && this.firstPanelSize ? {
        transform: VanillaFlicking.getDefaultCameraTransform(options.align, options.horizontal, this.firstPanelSize)
      } : {}
    };
    var panels = options.virtual && ((_b = options.panelsPerView) !== null && _b !== void 0 ? _b : -1) > 0 ? this._getVirtualPanels(h, initialized) : this._getPanels(h, initialized);
    return h(this.viewportTag, viewportData, [h(this.cameraTag, cameraData, panels), this.$slots.viewport]);
  },
  methods: {
    /* eslint-disable @typescript-eslint/naming-convention */
    _getSlots: function () {
      var _a, _b;

      return (_b = (_a = this.$slots.default) === null || _a === void 0 ? void 0 : _a.filter(function (slot) {
        return slot.tag;
      })) !== null && _b !== void 0 ? _b : [];
    },
    _fillKeys: function () {
      var vnodes = this._getSlots();

      vnodes.forEach(function (node, idx) {
        if (node.key == null) {
          node.key = "$_".concat(idx);
        }
      });
    },
    _bindEvents: function () {
      var _this = this;

      var flicking = this.vanillaFlicking;
      var events = Object.keys(VanillaFlicking.EVENTS).map(function (key) {
        return VanillaFlicking.EVENTS[key];
      });
      events.forEach(function (eventName) {
        flicking.on(eventName, function (e) {
          e.currentTarget = _this; // Make events from camelCase to kebab-case

          _this.$emit(eventName.replace(/([A-Z])/g, "-$1").toLowerCase(), e);
        });
      });
    },
    _checkPlugins: function () {
      var _a, _b;

      var _c = this.pluginsDiffer.update(this.plugins),
          list = _c.list,
          added = _c.added,
          removed = _c.removed,
          prevList = _c.prevList;

      (_a = this.vanillaFlicking).addPlugins.apply(_a, __spreadArray([], __read(added.map(function (index) {
        return list[index];
      })), false));

      (_b = this.vanillaFlicking).removePlugins.apply(_b, __spreadArray([], __read(removed.map(function (index) {
        return prevList[index];
      })), false));
    },
    _getPanels: function (h, initialized) {
      var slots = initialized ? VanillaFlicking.getRenderingPanels(this.vanillaFlicking, this.diffResult) : this._getSlots();
      return slots.map(function (slot) {
        return h("Panel", {
          key: slot.key
        }, [slot]);
      });
    },
    _getVirtualPanels: function (h, initialized) {
      var options = this.options;
      var _a = options.virtual.panelClass,
          panelClass = _a === void 0 ? "flicking-panel" : _a;
      var panelsPerView = options.panelsPerView;
      var flicking = this.vanillaFlicking;
      var renderingIndexes = initialized ? flicking.renderer.strategy.getRenderingIndexesByOrder(flicking) : VanillaFlicking.range(panelsPerView + 1);
      var firstPanel = flicking && flicking.panels[0];
      var size = firstPanel ? flicking.horizontal ? {
        width: firstPanel.size
      } : {
        height: firstPanel.size
      } : {};
      return renderingIndexes.map(function (idx) {
        return h("div", {
          key: idx,
          staticClass: panelClass,
          style: size,
          domProps: {
            "data-element-index": idx
          }
        });
      });
    }
  }
});

var version = "4.9.2";

var install = function (Vue) {
  Vue.component("Flicking", Flicking);
};

var plugin = {
  Flicking: Flicking,
  install: install,
  version: version
};

module.exports = plugin;
//# sourceMappingURL=flicking.cjs.js.map
